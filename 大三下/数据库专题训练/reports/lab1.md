## lab 1：记录管理 实验报告

### 一、基本功能

#### 1. 实现难点

##### 1.1. 表元信息的序列化与反序列化

首先是表元信息 `table_meta` 的序列化与反序列化，由于其中包含了 `column` 列向量，无法直接确定 `vector` 的大小，因此我在其余成员变量储存完毕后，首先记录和还原了 `vector` 的大小。

之后按照顺序将 `column` 信息逐步记录和还原，但其中 `name_` 为一个 `string`，同样无法确定其长度，因此我同样使用先储存长度，再写入字符数组的方式存储和还原。

##### 1.2. 字段和记录的序列化与反序列化

之后是字段和记录的序列化与反序列化。

对于字段，序列化只须调用虚函数 `Store` 即可，而在反序列化过程中，需要根据字段的类型 `FieldType` 来选择构造不同的 `Field` 子类，特别是对于 `StrField`，还需要注意传入字符串的长度，这可以通过表元信息中对应列的 `len_` 成员得知。

对于序列，由于我们实现的是定长记录存储，因此只需要按照顺序序列化和反序列化各个字段，并注意根据列的 `len_` 计算写入偏移量即可。

##### 1.3. 页面内的记录插入、更新、删除

然后是页面中记录的增删改。

增加记录时，我们先通过位图获得编号最小的空闲槽，以此确定记录的页 `id` 和槽 `id`，也就确定了 `Rid`。然后我们就可以调用刚刚实现的 `record_factory::StoreRecord` 用于记录的序列化存储。之后只须注意在位图中标记槽已使用以及页面被修改的标记即可。

删除记录时，由于定长记录的特点，我们不需要修改记录的序列化信息，只须在位图中标记对应槽编号重新可用即可，同时需要注意标记页面被修改的标记。

更新记录时，依然因为是定长记录，我们只要再次调用 `record_factory::StoreRecord` 覆盖原有记录的序列化信息即可，同样还要注意页面被修改的标记。

##### 1.4. 数据表层的记录插入、更新、删除

最后是数据表层面记录的增删改。

增加记录时，首先根据现有可用的页面情况，判断是否需要创建新的页面用以记录的插入，在插入之后，判断是否刚好使得页面用满而需要修改可用页面情况。

删除记录时，只需要根据 `Rid` 中的页 `id` 定位到页面，槽 `id` 定位到槽号，进而调用之前写好的页面内记录删除接口即可，注意由于删除后增加的空闲槽，需要将空闲页面对应修改为删除记录对应的页面以利用空闲空间。

更新记录时，只需要类比删除记录时的对应调用即可。

#### 2. 实现耗时

第一部分大约耗时 $1$ 小时，后面三部分总计耗时 $3$ 小时左右。

包含高级功能，总耗时约 $7\sim8$ 小时。

### 二、高级功能

#### 1. 功能选择

本次实验我选择了实现了变长记录存储这一功能，实现分支为 `lab1-advanced`，对应的 `commit-id` 为 `3b0bb917974a7365a7dc2b02fd80d5c00ea1f9fa`。

我的设计主要针对于 `FieldType` 为字符串 `StrField` 的列，考虑到许多字符串的实际有用长度远小于表元信息中的 `len_` 字段，因此对于字符串的变长存储可能会有利于同一页面中存储更多的记录条数。

#### 2. 功能设计

##### 2.1. 字段与记录的序列化与反序列化

考虑这样创建的一张表：

```sql
CREATE TABLE course (
    id INT NOT NULL PRIMARY KEY,
    name VARCHAR(32) NOT NULL,
    location VARCHAR(100) NOT NULL,
    credit INT DEFAULT 0
);
```

可以看到，其中 `id`、`credit` 均为定长字段，而 `name` 为可变长的字符串字段。

对于表中的一条记录 `(30240422, 'Database', '6A017', 2)`，我们按照 `(定长数据, 可变列的偏移数组, 变长数据)` 的方式存储变长记录，即：

| 偏移量 |    `0B`     |      `4B`       |          `8B`          |            `10B`            |     `12B`     |       `20B`       |
| :----: | :---------: | :-------------: | :--------------------: | :-------------------------: | :-----------: | :---------------: |
|  内容  | `30240422`  |       `2`       |          `20`          |            `25`             | `'Database'`  |      `6A017`      |
|  长度  |    `4B`     |      `4B`       |          `2B`          |            `2B`             |     `8B`      |       `5B`        |
|  含义  | 定长列 `id` | 定长列 `credit` | 变长列 `name` 结束位置 | 变长列 `localtion` 结束位置 | 变长列 `name` | 变长列 `location` |

可变列偏移数组的长度为 `2B` 乘上可变列的数目，通过定长列的总长度和不定长列的数量，我们可以得到不定长列数据的开始位置偏移量，并配合可变列偏移数组，确定每个可变长列数据在记录中的具体位置偏移量。

##### 2.2. 页面内布局

页头 `PageHeader` 增加了三个成员 `slot_num`、`free_offset`、`free_bytes` 分别表示：

- 当前槽数量（包含无效槽）；
- 空闲空间的字节偏移量；
- 空闲空间的字节数量。

页面管理中，我删除了位图 `bitmap_` 的使用。

页面的主体，从前向后存储记录的序列化结果，从后向前记录槽目录（即槽 `id` 对应记录在页面中的字节偏移量）。

槽目录按照每 $2$ 字节对应从 $0$ 开始的自然数编号，因此访问具体槽 `id` 的记录时，只需要 $O(1)$ 的寻址时间。

插入记录时，不是直接新增当前槽数量，而是先从后向前遍历，寻找是否存在无效槽，进而利用其原有的槽 `id`。

删除记录时，将对应槽 `id` 记录的字节偏移量设置为 $2^{16} - 1$（即 `unsigned short` 的最大值）用以表示无效槽。

更新记录时，由于不确定记录总长度的变化，我统一进行了先删除后插入的操作（此处实际上可以考虑对长度未变长的更新记录直接覆盖原有数据，以减少空间的浪费）。

##### 2.3. 数据表层的记录插入、更新、删除

插入记录时，由于没有了位图，所以对于每次插入能否在当前空闲页面需要做出修改，即判断页面的空闲空间字节数是否大于等于记录长度加上 $2$（用于槽目录），如果不足，需要寻找新的空闲页面以插入。

删除与更新记录与原有情况没有区别。

#### 3. 功能效果

我在原有的测例基础上设计了测例 `50_variable_length.sql`：

```sql
use dbtrain_test;

create table text_table_variable_length(id int, long_text char(1024));

insert into text_table_variable_length values(1, 'a');
insert into text_table_variable_length values(2, 'b');
-- 此处省略
insert into text_table_variable_length values(100, 'v');

select * from text_table_variable_length;
```

对于基本功能的版本：

![image-20220325162405824](https://img.wzf2000.top/image/2022/03/25/image-20220325162405824.png)

可以看到 `text_table_variable_length.data` 文件达到了近 $140\mathrm{KB}$ 大小。

对于高级功能的版本：

![image-20220325162532119](https://img.wzf2000.top/image/2022/03/25/image-20220325162532119.png)

可以看到 `text_table_variable_length.data` 文件仍然只有 $4\mathrm{KB}$ 大小。

当然同样也会发现，由于更多字段的引入，在字符串基本达到最长长度的情形下，高级功能版本的数据大小也会反而增大。

