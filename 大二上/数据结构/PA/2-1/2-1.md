## PA2a-1 Build

### 一、算法分析

本题的关键点在于所有操作的 `cost` 有上限，根据其数量级在 $10^6$ 级别，可猜测本题的算法复杂度应该基本与此呈线性关系。

考虑采用加入链表来存储树结构，每个非节点只连接第一个子结点，而子节点之间通过顺序的链表来连接，也就是：

```
1->2->3->...->n
```

这样，对于每个节点，我们只须存储其前驱、后继（可能为空），以及父亲节点即可描述这个树结构。

接下来考虑题中给出的操作，都基于定位一个点的操作，而这个操作只需要尝试在对应的子节点链表上走若干位即可，这个过程可以发现，是与一次操作的 `cost` 呈线性关系的。

由于询问操作是询问子树的大小和高度信息，所以考虑记录在每个节点上记录三个信息：

- 子树大小信息。
- 子树高度信息。
- 最大后缀子树高度信息

其中最大后缀子树高度是指，本节点及排在其之后的兄弟节点的子树高度最大值，也就是说，假设第 $i$ 个子结点的子树高度为 $\mathrm{height}_i$，其为第 $j$ 个子结点，则：
$$
\mathrm{suffix}_j = \max_{i \ge j} \mathrm{height}_i
$$
初始情况下，三种信息可以通过深度优先遍历方法得到：

- 按顺序递归遍历每个子结点，并且在这个过程中对其子树大小求和。
- 倒序遍历子结点，求出最大后缀子树高度信息。
- 对求得的子树大小和（不存在则为 $0$）加 $1$ 得到本节点的子树大小。
- 对第一个子节点（不存在则为 $0$）的最大后缀子树高度加 $1$ 得到本节点的高度信息。

然后我们只须考虑在子树移动过程中的信息维护即可。

对于子树大小，子树的移动只会影响导致其祖先（若干代父亲）的子树大小减少本节点的子树大小，并且使得插入点及其祖先的子树大小增加同样数量，所以只需在寻找对应节点的过程中取出整个链并进行修改即可。

对于子树高度信息和最大后缀子树高度信息，子树的删除和插入，会导致其兄弟前驱的最大后缀子树高度信息可能发生变化，导致其祖先的子树高度发生变化，其祖先及兄弟前驱的最大后缀子树高度信息发生变化，因此我们需要在寻找到对应节点的过程中，自底向上维护和更新对应的信息：

- 从当前节点向前重新计算最大后缀子树高度：
  $$
  \mathrm{suffix}_i = \max \{\mathrm{suffix}_{i + 1}, \mathrm{height}_i \}
  $$

- 到链表头后，用其更新父亲的信息：
  $$
  \mathrm{height}_{\mathrm{father}} = \mathrm{suffix}_1 + 1
  $$

- 递归进行父节点的计算。

通过这样的设计和维护，在查询时，只需要调取对应的子树高度信息和子树大小信息，即可得到答案。

### 二、复杂度分析

建立树的过程只与点数相关，时间复杂度为 $O(n)$。

深度优先遍历计算初始信息的过程也同理，时间复杂度也是 $O(n)$。

对于子树移动，移动本身只涉及寻找节点的过程，单次时间复杂度为 $O(\mathrm{cost})$，对于查询同理。

而对于维护的过程，子树大小信息只跟节点深度相关，因此复杂度仍然可认为是 $O(\mathrm{cost})$。

子树高度信息，相当于逆查找的过程，因此时间复杂度为 $O(\mathrm{cost})$。

综上所述，本算法的时间复杂度为 $O\left(\sum \mathrm{cost} + n \right)$，根据数据范围可知基本符合要求。

而存储上，只需要记录每个节点的：

- 前驱和后继编号。
- 父亲节点。
- 三个信息。
- 子结点数量。

因此空间复杂度整体为 $O(n)$。

### 三、问题与解决

本题中存在路径不合法的问题，需要提前截断，可以通过记录子节点数量的方法来快速方便的判断。

对于没有子节点的节点高度，需要特别处理和维护，可通过首尾节点的特判来解决。

