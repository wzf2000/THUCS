## PA3-1 Not Found

### 一、算法分析

先不考虑空间、时间限制，我们容易想到维护 $A$ 所有的前缀构成的字典树（Trie），那么此时这个字典树上最低出现空点的层中最左侧的点即为答案。

而对于长度为 $l$ 的 $0/1$ 串，其有 $2^l$ 次种可能，而串 $A$ 总共拥有 $|A| - l + 1$ 个长度为 $l$ 的可能，因此长度为 $l$ 的串全部在 $A$ 中出现的必要条件是：
$$
2^l \le |A| - l + 1 \le |A| \\
\Rightarrow l \le \log_2 |A|
$$
而 $|A| \le 2^{24}$，因此我们只需要考虑长度不超过 $24$ 的 $0/1$ 串即可。

首先可以想到枚举长度从 $1 \sim \min(24, |A|)$，对于每个长度 $i$，计算所有长度等于 $i$ 的子串，并且对于任意子串 $S_j$，并通过一个 `int` 值 $f(S_j)$ 来一一对应：

- 将子串看作对应的二进制表示，即 $f(S_j) = (S_j)_2$。
- 由于此时固定了子串长度，所以前导零并不会导致不同串的值重复。

那么我们最后只需要考虑 $0 \sim 2^{i} - 1$ 中是否有没有出现的值，如果有则最小的数代表的字符串即为答案。

但我们仍然可以进一步优化算法。

考虑长度为 $i(i \ge 2)$ 的子串 $S_1, S_2, \cdots, S_{|A| - i + 1}$，我们假设已经得出了其对应的元素值，并通过一些方法表示了每个值是否出现。

那么对于长度为 $i - 1$ 的子串 $S_{1}',S_{2}', \cdots, S_{|A| - i + 1}', S_{|A| - i + 2}'$，其中 $S_1', \cdots, S_{|A| - i + 1}'$ 即为 $S_1, \cdots, S_{|A| - i + 1}$ 减去末位。

那么容易得到：
$$
f(S_j') = \left \lfloor \frac{f(S_j)}{2} \right \rfloor
$$
因此，除去 $S_{|A| - i + 2}'$ 以外，任意一个数 $x$ 代表的串是否在长度为 $i - 1$ 的子串中出现，只取决于 $2x$ 和 $2x + 1$ 中的一个是否在长度为 $i$ 的子串中出现，而每个 $S_{|A| - i + 2}'$ 在最后统计末尾 $i - 1$ 位的贡献即可。

那么我们只需要在初始的第一次循环中枚举整个串，得到其所有长度为 $\max(24, |A|)$ 的子串对应的值，后续即可利用之前的结果来更新下一次循环所需要的信息。

而对于整个串的存储，可以采用压位表示的方法，如我采用了将相邻的 $64$ 位压缩成一个 `unsigned long long` 类型的值。

同理也可以对于原来所需要的判断 `bool` 数组进行压位，并且由于每次循环的 $x$ 总是在需要利用其值的 $x / 2$ 利用之后被更新，因此我们可以直接在原数组基础上修改而无需担心造成版本冲突问题。

### 二、复杂度分析

第一次枚举整个串以及读入需要时间为 $O(|A|)$，而之后每次对于长度 $i \le \max(24, |A|)$ 子串的特判只须 $O(i)$ 的时间，而对于整个所有可能子串的枚举复杂度为 $O(2^i)$，因此总体时间复杂度为 $O(|A| + 2^{24})$。

如果采取更严格的限制使得 $i \le \log_2 |A|$，我们可以得到整体时间复杂度为 $O(|A|)$。

对于原长度为 $2^{24}$ 的 $0 / 1$ 数组，按照算法，我们一次压缩 $64$ 位，因此只须 $2^{18}$ 的数组大小即可。

总体空间复杂度仍然是 $O(|A|)$，但所需空间可估算为 $8\mathrm{B} \times 2^{18} \times 2 = 4 \mathrm{MB}$（两个数组大小为 $2^{18}$，其余空间均为极少的临时变量），小于题目给出的 $6 \mathrm{MB}$ 限制。

### 三、问题与解决

不能一次性读入，因为无法给出完整的 `char` 数组，因此需要不断进行单次 `getchar()` 直到读入不为 $0 / 1$ 为止。

对于压位后的数组的利用较为麻烦，专门实现函数 `set_kth()` 和 `get_kth()` 会使得代码逻辑清晰。

在判断过程中可以多利用位运算加速运算。

