## PA1b 设计测例（Zuma）

### `01.cpp`

这份代码在不同的平台上表现不同，可能出现 `Time Limit Exceeded` 或者 `Runtime Error` 的错误。

#### 1. `Time Limit Exceeded`

这份代码使用了 `string` 类的插入功能，这一方法的时间复杂度是 $O(n)$ 的，理论上最坏复杂度会达到 $O(n^2 + nm)$ 左右。

因此我们只需要构造每次插入都会导致 $O(n)$ 级别的字符串向后移动的数据并保证不因为消除减少过多长度即可，一种可行构造方式如下：

```cpp
#include <iostream>

using namespace std;

int main()
{
    for (int i = 0; i < 500000; ++i)
        putchar(i % 26 + 'A');
    puts("");
    puts("500000");
    for (int i = 0; i < 500000; ++i)
        printf("260000 "), putchar(i % 26 + 'A'), puts("");
    return 0;
}

```

在这个测例中，我们可以发现，每次插入并不会引起任何消除，但每次插入会导致至少 $240000$ 的字符串向后移动一位，因此运行时间必然会远远超出限制。

对应的测例即为最终版本中的 `01.in` 文件。

#### 2. `Runtime Error`

这份代码在消除到最左侧时，会使得 `left` 坐标变为 $0$，那么在 `play()` 函数的递归时，便会导致 `rank` 值为 $-1$，使得 `string` 类型的 `a` 被访问了负数坐标。

这种情况在一些运行环境下可能导致 `Runtime Error` 的结果，我们可以构造测例：

```
AA
1
1 A
```

这种情况下，一次递归后 `rank` 将变为 $-1$。

### `02.cpp`

#### 1. `Time Limit Exceeded`

与 `01.cpp` 相同，同样的数据和原因将导致其超时。

### `03.cpp`

#### 1. `Time Limit Exceeded`

与 `01.cpp` 相同，同样的数据和原因将导致其超时。

### `04.cpp`

#### 1. `Wrong Answer`

这份代码的 `left` 坐标有误，错将左侧第一个不是 `color` 的珠子当成了左侧第一个是 `color` 的珠子。

因此只须构造一个在插入处至少有连续两个同颜色的珠子，并且同颜色最左侧不为 $0$ 即可，例如测例：

```
BA
1
1 A
```

这样的情况下，`left` 和 `right` 坐标将分别为 $0$ 和 $3$，会让程序进行消除操作，然而实际上序列并不满足消除条件。

### `05.cpp`

#### 1. `Wrong Answer`

这份代码的读入未考虑到空行情况，于是只需要构造合理的空行即可导致读入不完整等问题，例如测例：

```

3
0 A
0 B
0 A
```

代码读入的 `m` 将因为没有读入空行而变为 $0$，因此代码认为没有任何操作，而原序列为 `3`，于是输出 `3`，实际上应为 `ABA`。

### `06.cpp`

#### 1. `Time Limit Exceeded`

与 `01.cpp` 类似，同样的数据将导致其超时。

这份代码虽然使用了分块链表的做法，但对于单块的大小却没有限制。

我们只须构造不断向同一个位置插入珠子但保证不消除即可使得其每次插入复杂度转为 $O(n)$ 级别。

具体数据生成与 `01.cpp` 完全相同，可以发现，每次插入的复杂度都会逐渐增大，最终时间复杂度显然会趋近于：
$$
O\left(1 + 2 + 3 + \cdots + m\right) = O\left(m^2\right)
$$
因此必然会导致超时。

### `07.cpp`

#### 1. `Time Limit Exceeded`

与 `06.cpp` 类似，同样的数据和原因将导致其超时。

#### 2. `Runtime Error`

这份代码的 `checkLeft()` 函数在达到最左侧时，会导致返回的 `head` 值为 $-1$，在确实存在消除的情况下，`head` 值会被用于第 $207$ 行的语句：

```cpp
char left = lParent->balls[head];
```

而 `myVector` 类重载的 `[]` 运算符只会在下标大于等于 $0$ 且小于 `_size` 时才返回一个引用，这意味着当 传入一个负数（$-1$）时，重载函数将没有返回值。

于是我们可以构造测例：

```
AA
1
0 A
```

这样便可使得程序在一些运行环境下出现 `Runtime Error` 的错误。

### `08.cpp`

#### 1. `Wrong Answer`

这份代码在得出包括连消的消除区间后 `(head, tail)​`，需要将 `head` 右移一格找到 `[head, tail)`，但是其只考虑到了 `head` 在当前分块最右侧的可能。

因此我们只须构造 `head` 不为当前分块的最右侧即可，比如：

```
ABBCDEFGH
1
1 B
```

分块代码会将序列分为三段，每段三个珠子。

而插入 `B` 后，显然 `left` 会变为第一块的 $0$ 位置，`right` 变为第二块的 $0$ 位置。

此时经过以下代码处理：

```cpp
//找到 [head,tail)，即将head向右挪动一格
while (head + 1 >= start->size())		//确保head不会走到 END:前提已经满足必定有相消位
{
	start = start->next;
	head = 0;
}
```

`left` 并不会有变化，这意味着实际上序列的第一个珠子即 `A` 也会被连带消除，因此造成错误答案。

### `09.cpp`

#### 1. `Wrong Answer`

本代码在消除时，没有考虑到包含连消的消除区间在同一个分块内的情况。

因此只须构造同一个分块内的消除，便可导致每一块的大小出现问题，再配合之后的操作可让答案错误。

比如通过以下方法构造测例：

```cpp
#include <iostream>

using namespace std;

int main()
{
    for (int i = 0; i < (1 << 11) + 2; i++)
        putchar('A' + i % 26);
    puts("");
    puts("6");
    for (int i = 0; i < 3; i++)
        printf("%d A\n", (1 << 11) + 1);
    for (int i = 0; i < 3; i++)
        printf("%d %c\n", (1 << 11) + 1, 'B' + i);
    return 0;
}

```

这会导致第二个分块内部出现消除，经过下面语句：

```cpp
if (l.first >= 0) {
    plen[l.first] = l.second + 1;
}
if (r.first < pn) {
    int len = plen[r.first] - r.second;
    if (len > 0) {
        memmove(&p[r.first][0], &p[r.first][r.second], len);
    }
    plen[r.first] = len;
}
```

会导致 `plen[1]` 的值变为 $-3$。

直接在此结束会使得程序出现 `Runtime Error` 错误。

如果在第二个分块再插入三个元素而不产生消除，则将会使得 `plen[1]` 的值变为 $0$，恢复正常。

但此时输出会导致之后加入的三个元素，以及初始的最后两个元素未被输出，因此答案错误。

### `10.cpp`

#### 1. `Wrong Answer`

这份代码在处理完单次消除之后，对于下次循环的 `r` 的处理是：

```cpp
r = l;
r.second += 1;
```

这意味着如果单次消除是跨分块的，且 `l` 在消除完某次后成为了块内最右边的元素，则 `r` 就成为了不存在（已被消除）的元素，而在之后下一次循环内，`r` 必然无法继续向右探索。

因此我们可以构造这种情况，并且右侧块内与左侧块剩余部分恰好还能构成一次消除，即可使得本代码出现本应消除却无法消除的情形。

比如下列构造测例的方法：

```cpp
#include <iostream>

using namespace std;

int main()
{
    for (int i = 0; i < 2050; i++)
        putchar('A' + (i / 2) % 2);
    puts("");
    puts("1");
    puts("1025 A");
    return 0;
}

```

其会导致在若干次消除之后，局面变为了 `AA|AA` 的分块情况，而此时 `l` 是第一块内的 $1$ 位置，`r` 由上面代码变为了第二块内的 $2$ 位置（实际不存在）。

于是下一次向右的尝试拓展会失败，程序认为只有左侧两个连续一样的，就停止了连消，输出为 `AAAA`，而实际应该的输出则为空，造成了答案错误。

