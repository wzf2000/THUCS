## PA1a-4 Risk

### 一、算法分析

本题需要对于每一天的区间也就是 $[i - m_i, i - 1]$ 维护确诊病例最大值，也就是动态维护区间最大值。

然后根据计算得出的各个最大值，对于每个询问 $p, q$，计算小于 $p$ 和小于 $q$ 的值个数，即可得到低风险天数和中风险天数。

对于区间最大值的计算，一种方式是通过线段树、平衡树等数据结构维护区间性质，但这种方式的时间复杂度明显过高，而且也没有利用到本题的性质，即第 $i$ 天向前追溯到的最早天数，不会比第 $i - 1$ 天向前追溯到的最早天数更早。

这个性质说明，随着天数的增加，每天对应的时间区间的左右端点都是单调向右移动的。

容易发现，这个区间中相当于一个队列， 不断地有从队首退队的元素以及从队尾入队的元素。

考虑当前的一个队列 $a[l\sim r]$，如果存在元素 $a[i], a[j]$ 满足 $l \le i < j \le r$ 且 $a[i] \le a[j]$，则由于 $a[j]$ 必然晚于 $a[i]$ 退队，也就是说从当前开始，$a[i]$ 生效的时间中，$a[j]$ 必然也生效。

而由于 $a[j] \ge a[i]$，故这段时间内区间（队列）中的最大值必然不小于 $a[r]$，这意味着 $a[i]$ 在这段时间内对于区间（队列）最大值是没有贡献的。

换句话说，我们只需要保留队列中单调下降的子序列即可，如此，每个区间的最大值就会是当前的队首元素。

具体来说，我们在每次区间移动时需要：

1. 将当前队首下标小于 $i - m_i$ 的元素退队：

   ```cpp
   while (head <= tail && queue[head] < (static_cast<long long>(i) - static_cast<long long>(m)))
       head++;
   ```

2. 根据队首元素得到对于第 $i$ 天区间的最大值：

   ```cpp
   if (head <= tail)
   	k[i] = x[queue[head]];
   else
   	k[i] = 0;
   ```

3. 将队尾小于等于即将加入的 $x[i]$ 的元素退队：

   ```cpp
   while (head <= tail && x[i] >= x[queue[tail]])
   	tail--;
   ```

4. 将 $x[i]$ 元素入队：

   ```cpp
   queue[++tail] = i;
   ```

这也就是单调队列或者又称 **Queap** 的数据结构。

通过如此方式计算得到各区间的最大值后，我们可以通过排序和二分查找的方式获取小于等于 $p$ 的数的个数，但这样做的时间复杂度较高且较为烦琐。

考虑到每日确诊人数至多为 $2 \times 10^6$，我们可以通过数组记录区间最大值等于某一个数的天数，再通过求取前缀和获知需求的信息。

### 二、复杂度分析

对于第一部分，如果采取高级数据结构维护，时间复杂度将约为 $O(n \log n)$，空间复杂度为 $O(n)$。

而对于上面说到的单调队列做法，由于每个元素至多入队、出队一次，且外部循环也仅是 $1 \sim n$，因此时间复杂度为 $O(n)$，空间复杂度也容易发现为 $O(n)$。

对于第二部分的查询，如果采取排序加二分查找的方式，则时间复杂度应为 $O(n \log n + T \log n)$，空间复杂度为 $O(n)$。

但通过数组前缀和的方式，时间复杂度将变为 $O(\max x_i + T)$，空间复杂度为 $O(\max x_i + n)$。

故最终算法整体的时间复杂度为 $O(n + \max x_i)$，空间复杂度为 $O(n + \max x_i)$。

### 三、问题与解决

输入多处出现了 $2^{32}$ 的范围，`int` 型数据难以存储，需要通过 `unsigned int` 类型甚至 `long long` 类型的转换。

而读入优化部分默认的依然是 `int` 类型，但由于 `int` 类型溢出到 $2^{31} \sim 2^{32} - 1$ 范围内时，实际上会变为负数，与利用 `unsigned int` 存储时的数恰好对应，因此直接将 `int` 类型转换为 `unsigned int` 即可获知输入的实际大小。

