## PA3-3 kth

### 一、算法分析

首先先通过固定另外两维为 $1$，来对每个数组进行排序（可采用快速排序）。

首先最小方案一定是 $a[1] + b[1] + c[1]$（排序后），而 $a[i] + b[j] + c[k]$ 的方案一定不优于 $a[u] + b[v] + c[w]$，如果 $u \le i, v \le j, w \le k$，因此只有 $a[i - 1] + b[j] + c[k], a[i] + b[j - 1] + c[k], a[i] + b[j] + c[k - 1]$ 三种方案考虑后（如果方案合理），才应该被考虑。

因此我们可以考虑用堆维护当前的最小值，每次取出堆顶 $(i, j, k)$ 的方案，再向堆中加入 $(i + 1, j, k), (i, j + 1, k), (i, j, k + 1)$ 三种方案（如果方案合理）。

初始堆中插入 $(1, 1, 1)$ 方案，循环 $k$ 次，则第 $i$ 次取出的就恰好是第 $i$ 小的方案。

但如果这样实现，一个方案都可能被插入多次，因此需要在插入前判重，可以考虑采用散列存储已经加入的方案。

也可以采用更好的入堆顺序，即规定每个方案的访问顺序，必须是先加第一维，再加第二维，最后第三维。

实现上只需要：

- 对于 $j = 1, k = 1$ 的方案，三种方案均插入堆。
- 否则对于 $k = 1$ 的方案，只加入 $(i, j + 1, k)$ 和 $(i, j, k + 1)$ 两种方案。
- 其他方案，只加入 $(i, j, k + 1)$ 的方案。

这样可以保证每个方案有唯一的前驱，保证不出现重复。

### 二、复杂度分析

排序部分的时间复杂度为 $O(n \log n)$。

堆维护过程中，至多取出 $k$ 个元素，至多插入 $3k$ 个元素，因此复杂度为 $O(k \log k)$。

因此总体时间复杂度为 $O(n \log n + k \log k)$。

### 三、问题与解决

本题未给出三个数组的具体数值，因此在排序和堆的维护中的比较，均只能采用给出的 `compare()` 接口，可以考虑重载 `<` 和使用模板类来简化代码。

