## PA1a-3 filename

### 一、算法分析

我们可以定义状态 `dp[i][j]`，代表使用 $A$ 串的前 $i$ 位匹配（对应）了 $B$ 串的前 $j$ 位，最少的修改代价次数。

那么容易得到几种状态转移方程：

1. 直接将 $A$ 的第 $i + 1$ 位与 $B$ 的第 $j + 1$ 位匹配，也就是：

   ```cpp
   if (A[i + 1] == B[j + 1])
       dp[i + 1][j + 1] = min(dp[i + 1][j + 1], dp[i][j]);
   ```

2. 将 $A$ 的第 $i + 1$ 位删去，也就是：

   ```cpp
   dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + 1);
   ```

3. 添加 $B$ 的第 $j + 1$ 位与之匹配，也就是：

   ```cpp
   dp[i][j + 1] = min(dp[i][j + 1], dp[i][j] + 1);
   ```

这种算法的复杂度明显不够优秀，所以考虑优化。

对于 `dp[i][j]`，我们容易发现：
$$
dp[i][j] \ge |i - j|
$$
因此，对于 $|i - j| > K$ 的状态，实际上是无意义的，也就是说，我们只需要维护 $|i - j| \le K$ 的状态。

并且由于 `dp[i + 1]` 的状态，我们只会用 `dp[i + 1]` 和 `dp[i]` 的状态来维护，所以我们可以用滚动数组来降低空间复杂度。

现在我们定义 `dp[now][j]` 表示原来 `dp[i][i + j - 100]` 的含义，而 `dp[last][j]` 表示原来 `dp[i - 1][i + j - 101]` 的含义，即可完成算法时间复杂度和空间复杂度的优化。

### 二、复杂度分析

上述状态转移复杂度显然为 $O(1)$。

因此朴素动态规划算法的时间复杂度容易得到为 $O(nm)$，空间复杂度也为 $O(nm)$。

而经过优化，我们对于固定的 $i$ 只需要维护 $[100 - K, 100 +K]$ 这个区间中的 $j$，因此时间复杂度为 $O(nK)$，空间复杂度同样容易发现为 $O(n + K)$。

### 三、问题与解决

对于读入数据 $|n - m| > K$ 的情况，可能导致状态数组出错，但这种情况显然不存在低于 $K$ 的代价，因此直接输出 $-1$ 即可。

