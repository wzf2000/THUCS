## PA2a-4 Kidd

### 一、算法分析

本题容易想到采用线段树进行维护，只需要维护区间的和以及 Lazy Tag 即可。

但由于区间的范围在 $2^{31}$ 级别，因此空间上难以存储。

因此考虑进行对区间离散化。

由于所有的 $m$ 次操作，最多涉及 $m$ 个区间，$2m$ 个端点，我们可以考虑只维护涉及到的关键点信息。

对于区间 $[l, r]$ 也就是 $[l, r + 1)$，我们取 $l, r + 1$ 作为其关键节点。

将 $m$ 个区间的关键点取出，并排序去重，再把原来的端点映射为其在此数组（数列）中的次序号。

设排序去重后的关键点数列为：
$$
x_0, x_1, \cdots, x_{k - 1}, x_k = n
$$
则对于 $x_i$，我们令其管辖区间 $[x_i, x_{i + 1})$ 段（$0 \le i < k$），则容易发现，这个区间的点必然同时被翻转和询问。

那么假设询问区间的 $l, r + 1$ 分别对应 $x_i, x_j$，那么其就可以通过 $x_i, x_{i + 1}, \cdots, x_{j - 1}$ 这些点管辖的区间求和（取并集）得到，也就是说，我们可以将此区间重新映射为了 $[i, j)$。

而在线段树的实现上，我们只须将原来用到的区间长度信息由 $r - l + 1$ 修改为 $x_{r + 1} - x_l$ 即可。

### 二、复杂度分析

在离散化过程中，至多出现 $2m$ 个关键点，因此离散化部分的复杂度为 $O(m \log m)$。

线段树部分的时间复杂度，容易得到与普通线段树无区别，同样为 $O(m \log m)$。

因此总体时间复杂度为 $O(m \log m)$。

而空间复杂度，根据普通线段树存储需要 $4$ 倍区间长度可知，为 $O(m)$。

### 三、问题与解决

输入最大可能达到 $2^{31} - 1$，因此关键节点可能达到 $2^{31}$，因此需要采用 `unsigned int` 类型存储防止越界。

区间和可能达到 $O(nm)$ 级别，因此和数组应该采用 `unsigned long long` 类型存储。



